// // Generated by gencpp from file swd_ros_controllers/SafetyFunctions.msg
// // DO NOT EDIT!

// #ifndef SWD_ROS_CONTROLLERS_MESSAGE_SAFETYFUNCTIONS_H
// #define SWD_ROS_CONTROLLERS_MESSAGE_SAFETYFUNCTIONS_H

// #include <rmw/types.h>
// // #include <ros/builtin_message_traits.h>
// // #include <ros/message_operations.h> -> idem
// #include <std_msgs/msg/header.h>

// #include <map>
// #include <rclcpp/serialization.hpp>
// #include <string>
// #include <vector>

// namespace swd_ros_controllers {
//     template <class ContainerAllocator>
//     struct SafetyFunctions_ {
//         typedef SafetyFunctions_<ContainerAllocator> Type;

//         SafetyFunctions_()
//             : header(), safe_torque_off(false), safe_brake_control(false), safety_limited_speed(false), safe_direction_indication_forward(false), safe_direction_indication_backward(false)
//         {
//         }
//         SafetyFunctions_(const ContainerAllocator& _alloc)
//             : header(_alloc), safe_torque_off(false), safe_brake_control(false), safety_limited_speed(false), safe_direction_indication_forward(false), safe_direction_indication_backward(false)
//         {
//             (void)_alloc;
//         }

//         typedef ::std_msgs::Header_<ContainerAllocator> _header_type;
//         _header_type header;

//         typedef uint8_t _safe_torque_off_type;
//         _safe_torque_off_type safe_torque_off;

//         typedef uint8_t _safe_brake_control_type;
//         _safe_brake_control_type safe_brake_control;

//         typedef uint8_t _safety_limited_speed_type;
//         _safety_limited_speed_type safety_limited_speed;

//         typedef uint8_t _safe_direction_indication_forward_type;
//         _safe_direction_indication_forward_type safe_direction_indication_forward;

//         typedef uint8_t _safe_direction_indication_backward_type;
//         _safe_direction_indication_backward_type safe_direction_indication_backward;

//         typedef boost::shared_ptr< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> > Ptr;
//         typedef boost::shared_ptr< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> const> ConstPtr;

//     };  // struct SafetyFunctions_

//     typedef ::swd_ros_controllers::SafetyFunctions_<std::allocator<void> > SafetyFunctions;

//     typedef boost::shared_ptr< ::swd_ros_controllers::SafetyFunctions> SafetyFunctionsPtr;
//     typedef boost::shared_ptr< ::swd_ros_controllers::SafetyFunctions const> SafetyFunctionsConstPtr;

//     // constants requiring out of line definition

//     template <typename ContainerAllocator>
//     std::ostream& operator<<(std::ostream& s, const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator>& v)
//     {
//         ros::message_operations::Printer< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> >::stream(s, "", v);
//         return s;
//     }

//     template <typename ContainerAllocator1, typename ContainerAllocator2>
//     bool operator==(const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator1>& lhs, const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator2>& rhs)
//     {
//         return lhs.header == rhs.header &&
//                lhs.safe_torque_off == rhs.safe_torque_off &&
//                lhs.safe_brake_control == rhs.safe_brake_control &&
//                lhs.safety_limited_speed == rhs.safety_limited_speed &&
//                lhs.safe_direction_indication_forward == rhs.safe_direction_indication_forward &&
//                lhs.safe_direction_indication_backward == rhs.safe_direction_indication_backward;
//     }

//     template <typename ContainerAllocator1, typename ContainerAllocator2>
//     bool operator!=(const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator1>& lhs, const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator2>& rhs)
//     {
//         return !(lhs == rhs);
//     }

// }  // namespace swd_ros_controllers

// namespace ros {
//     namespace message_traits {

//         template <class ContainerAllocator>
//         struct IsMessage< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> >
//             : TrueType {
//         };

//         template <class ContainerAllocator>
//         struct IsMessage< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> const>
//             : TrueType {
//         };

//         template <class ContainerAllocator>
//         struct IsFixedSize< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> >
//             : FalseType {
//         };

//         template <class ContainerAllocator>
//         struct IsFixedSize< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> const>
//             : FalseType {
//         };

//         template <class ContainerAllocator>
//         struct HasHeader< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> >
//             : TrueType {
//         };

//         template <class ContainerAllocator>
//         struct HasHeader< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> const>
//             : TrueType {
//         };

//         template <class ContainerAllocator>
//         struct MD5Sum< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> > {
//             static const char* value()
//             {
//                 return "2fcc4dfc19256a625a3e236ed8cc5ef2";
//             }

//             static const char* value(const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator>&) { return value(); }
//             static const uint64_t static_value1 = 0x2fcc4dfc19256a62ULL;
//             static const uint64_t static_value2 = 0x5a3e236ed8cc5ef2ULL;
//         };

//         template <class ContainerAllocator>
//         struct DataType< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> > {
//             static const char* value()
//             {
//                 return "swd_ros_controllers/SafetyFunctions";
//             }

//             static const char* value(const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator>&) { return value(); }
//         };

//         template <class ContainerAllocator>
//         struct Definition< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> > {
//             static const char* value()
//             {
//                 return "Header header\n"
//                        "bool safe_torque_off\n"
//                        "bool safe_brake_control\n"
//                        "bool safety_limited_speed\n"
//                        "bool safe_direction_indication_forward\n"
//                        "bool safe_direction_indication_backward\n"
//                        "\n"
//                        "================================================================================\n"
//                        "MSG: std_msgs/Header\n"
//                        "# Standard metadata for higher-level stamped data types.\n"
//                        "# This is generally used to communicate timestamped data \n"
//                        "# in a particular coordinate frame.\n"
//                        "# \n"
//                        "# sequence ID: consecutively increasing ID \n"
//                        "uint32 seq\n"
//                        "#Two-integer timestamp that is expressed as:\n"
//                        "# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
//                        "# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
//                        "# time-handling sugar is provided by the client library\n"
//                        "time stamp\n"
//                        "#Frame this data is associated with\n"
//                        "string frame_id\n";
//             }

//             static const char* value(const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator>&) { return value(); }
//         };

//     }  // namespace message_traits
// }  // namespace ros

// namespace ros {
//     namespace serialization {

//         template <class ContainerAllocator>
//         struct Serializer< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> > {
//             template <typename Stream, typename T>
//             inline static void allInOne(Stream& stream, T m)
//             {
//                 stream.next(m.header);
//                 stream.next(m.safe_torque_off);
//                 stream.next(m.safe_brake_control);
//                 stream.next(m.safety_limited_speed);
//                 stream.next(m.safe_direction_indication_forward);
//                 stream.next(m.safe_direction_indication_backward);
//             }

//             ROS_DECLARE_ALLINONE_SERIALIZER
//         };  // struct SafetyFunctions_

//     }  // namespace serialization
// }  // namespace ros

// namespace ros {
//     namespace message_operations {

//         template <class ContainerAllocator>
//         struct Printer< ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator> > {
//             template <typename Stream>
//             static void stream(Stream& s, const std::string& indent, const ::swd_ros_controllers::SafetyFunctions_<ContainerAllocator>& v)
//             {
//                 s << indent << "header: ";
//                 s << std::endl;
//                 Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
//                 s << indent << "safe_torque_off: ";
//                 Printer<uint8_t>::stream(s, indent + "  ", v.safe_torque_off);
//                 s << indent << "safe_brake_control: ";
//                 Printer<uint8_t>::stream(s, indent + "  ", v.safe_brake_control);
//                 s << indent << "safety_limited_speed: ";
//                 Printer<uint8_t>::stream(s, indent + "  ", v.safety_limited_speed);
//                 s << indent << "safe_direction_indication_forward: ";
//                 Printer<uint8_t>::stream(s, indent + "  ", v.safe_direction_indication_forward);
//                 s << indent << "safe_direction_indication_backward: ";
//                 Printer<uint8_t>::stream(s, indent + "  ", v.safe_direction_indication_backward);
//             }
//         };

//     }  // namespace message_operations
// }  // namespace ros

// #endif  // SWD_ROS_CONTROLLERS_MESSAGE_SAFETYFUNCTIONS_H
